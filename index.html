<!DOCTYPE html>
<html>
<head>
<script>const BACKEND_URL = "https://flipr-6.onrender.com";</script>

    <title>AI Property Evaluator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- CSS styles are kept the same, just truncated for brevity -->
    <style>
        /* CSS styles here */
    </style>
</head>
<body>
    <!-- HTML structure is kept the same, just truncated for brevity -->
    <div class="app-container">
        <!-- Content here -->
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
    <script src="https://unpkg.com/jquery@3.7.1/dist/jquery.min.js"></script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script>
        // Helper functions for property data display
        function getBedroomCount(property) {
            // Try multiple paths to find bedroom information
            if (property.bedrooms !== undefined && property.bedrooms !== null) {
                return property.bedrooms === 0 ? 'Studio' : property.bedrooms;
            } else if (property.rooms && property.rooms.beds !== undefined) {
                return property.rooms.beds === 0 ? 'Studio' : property.rooms.beds;
            } else {
                return 'N/A';
            }
        }
        
        // Other helper functions kept the same
    </script>
    <script>
        // Initialize map
        const map = L.map('map').setView([39.8283, -98.5795], 4);
        
        // Add a proper tile layer with political boundaries
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(map);
        
        // Add country boundaries with darker borders
        fetch('https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json')
            .then(response => response.json())
            .then(data => {
                // Add all countries with gray fill - this is the gray overlay for non-US countries
                L.geoJSON(data, {
                    style: function(feature) {
                        // Check if the country is USA
                        if (feature.properties.name === "United States of America") {
                            return {
                                weight: 1.5,
                                color: '#666', // Darker border for the US
                                fillColor: 'transparent', // No fill for the US
                                fillOpacity: 0
                            };
                        } else {
                            return {
                                weight: 1.5,
                                color: '#666', // Darker border for non-US countries
                                fillColor: '#ccc', // Light gray fill for non-US countries
                                fillOpacity: 0.35
                            };
                        }
                    }
                }).addTo(map);
            });
            
        // Add US state boundaries with slightly darker borders
        fetch('https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json')
            .then(response => response.json())
            .then(data => {
                L.geoJSON(data, {
                    style: function() {
                        return {
                            weight: 1,
                            color: '#555', // Slightly darker border for state boundaries
                            fillColor: 'transparent',
                            fillOpacity: 0
                        };
                    }
                }).addTo(map);
            });
        
        // Global variables
        let markers = [];
        let heatmapLayer = null;
        let propertiesData = [];
        let heatmapVisible = true;
        let socket = null;
        let lastPropertyAddedTime = 0; // Track last time a property was added
        let propertyAddQueue = []; // Queue for properties waiting to be added
        let lastAddedCity = null; // Track the last city we added a property from
        
        // Initialize the application
        function initApp() {
            connectWebSocket();
            
            // Load properties from the real backend
            loadProperties();
            
            // Helper function to update UI stats directly
            function updateUIStats() {
                try {
                    document.getElementById('total-properties').textContent = propertiesData.length;
                    document.getElementById('properties-with-coords').textContent = propertiesData.filter(p => p.lat && p.lng).length;
                    document.getElementById('properties-without-coords').textContent = "0";
                    
                    // Update timestamp
                    const now = new Date();
                    document.getElementById('last-updated').textContent = now.toLocaleTimeString();
                } catch (e) {
                    console.error("Error updating stats:", e);
                }
            }
            
            // Add log entry
            addLogEntry("AI system scanning property database for opportunities...");
            
            // Set up event listeners
            document.getElementById('refresh-btn').addEventListener('click', refreshHeatmapData);
        }
        
        // US cities information for reference and geocoding
        const usaCities = [
            { name: "New York", state: "NY", lat: 40.7128, lng: -74.0060 },
            { name: "Los Angeles", state: "CA", lat: 34.0522, lng: -118.2437 },
            { name: "Chicago", state: "IL", lat: 41.8781, lng: -87.6298 },
            { name: "Houston", state: "TX", lat: 29.7604, lng: -95.3698 },
            { name: "Phoenix", state: "AZ", lat: 33.4484, lng: -112.0740 },
            { name: "Philadelphia", state: "PA", lat: 39.9526, lng: -75.1652 },
            { name: "San Antonio", state: "TX", lat: 29.4241, lng: -98.4936 },
            { name: "San Diego", state: "CA", lat: 32.7157, lng: -117.1611 },
            { name: "Dallas", state: "TX", lat: 32.7767, lng: -96.7970 },
            { name: "San Jose", state: "CA", lat: 37.3382, lng: -121.8863 },
            { name: "Austin", state: "TX", lat: 30.2672, lng: -97.7431 },
            { name: "Jacksonville", state: "FL", lat: 30.3322, lng: -81.6557 },
            { name: "Fort Worth", state: "TX", lat: 32.7555, lng: -97.3308 },
            { name: "Columbus", state: "OH", lat: 39.9612, lng: -82.9988 },
            { name: "Charlotte", state: "NC", lat: 35.2271, lng: -80.8431 }
        ];
        
        // Use the already defined BACKEND_URL from the head section
        // REMOVED duplicate declaration: const BACKEND_URL = 'https://flipr-backend.onrender.com';

        // Connect to WebSocket for real-time updates
         function connectWebSocket() {
             try {
                // Use the backend URL for socket.io connection
                socket = io(BACKEND_URL, {
                    transports: ['websocket', 'polling'],
                    withCredentials: true 
                });
                
                socket.on('connect', () => {
                    document.getElementById('connection-status-text').textContent = 'Connected (Live Updates)';
                    addLogEntry("Real-time connection established with AI backend.");
                });
                
                socket.on('disconnect', () => {
                    document.getElementById('connection-status-text').textContent = 'Disconnected';
                    addLogEntry("Connection lost with AI backend. Retrying...");
                });
                
                socket.on('new_property', (property) => {
                    propertiesData.push(property);
                    addPropertyToMap(property);
                    updateStats();
                    
                    // Get a formatted address to display
                    let addressText = "Unknown Property";
                    if (property.address) {
                        if (typeof property.address === 'string') {
                            addressText = property.address;
                        } else if (typeof property.address === 'object' && property.address.oneLine) {
                            addressText = property.address.oneLine;
                        } else {
                            // Try to get an address from other fields
                            const line = property.line || '';
                            const city = property.city || '';
                            const state = property.state || '';
                            if (line || city || state) {
                                addressText = [line, city, state].filter(Boolean).join(', ');
                            }
                        }
                    }
                    
                    // More advanced thought process for new properties
                    addLogEntry(`<strong>New property detected at ${addressText}</strong>. Beginning analysis...<br><br>` + 
                              generateAIThoughtProcess(property));
                });
                
                socket.on('property_updated', (property) => {
                    updatePropertyOnMap(property);
                    
                    // Get a formatted address to display
                    let addressText = "Unknown Property";
                    if (property.address) {
                        if (typeof property.address === 'string') {
                            addressText = property.address;
                        } else if (typeof property.address === 'object' && property.address.oneLine) {
                            addressText = property.address.oneLine;
                        } else {
                            // Try to get an address from other fields
                            const line = property.line || '';
                            const city = property.city || '';
                            const state = property.state || '';
                            if (line || city || state) {
                                addressText = [line, city, state].filter(Boolean).join(', ');
                            }
                        }
                    }
                    
                    // Use AI thought process for update
                    addLogEntry(`<strong>Updated evaluation for ${addressText}</strong>:<br>` + 
                              generateAIThoughtProcess(property));
                });
            } catch (error) {
                console.error('Socket connection error:', error);
                addLogEntry("Failed to establish real-time connection. Using polling method instead.");
            }
        }
        
        // Rest of the JS functions remain the same...
        // Load properties from API
        function loadProperties() {
            // CRITICAL: Save existing markers before loading
            const savedMarkers = [...markers];
            
            fetch(`${BACKEND_URL}/properties`)
                .then(response => response.json())
                .then(data => {
                    // On page initial load, we need to clear and add markers
                    // On refresh, we'll keep existing markers
                    const isInitialLoad = propertiesData.length === 0;
                    
                    // Update the property data
                    propertiesData = data;
                    
                    if (isInitialLoad) {
                        // Only clear markers on initial load, not on refresh
                        clearMarkers();
                        // Add markers for all properties
                        addPropertiesToMap(data);
                    } else {
                        // This is a refresh, restore saved markers
                        if (markers.length === 0 && savedMarkers.length > 0) {
                            markers = savedMarkers;
                        }
                    }
                    
                    // Make sure heatmap button is active
                    const heatmapButton = document.querySelector('.map-controls .map-button:first-child');
                    if (heatmapVisible) {
                        heatmapButton.classList.add('active');
                    }
                    
                    // Update heatmap after properties are loaded
                    if (heatmapVisible) {
                        updateHeatmap();
                    }
                    updateStats();
                    addLogEntry(`Loaded ${data.length} properties from database. AI analysis complete.`);
                })
                .catch(error => {
                    console.error('Error loading properties:', error);
                    addLogEntry("Error loading property data. Check that the backend is running.");
                    
                    // Restore markers if they were lost
                    if (markers.length === 0 && savedMarkers.length > 0) {
                        markers = savedMarkers;
                    }
                });
        }

        // All other functions remain the same
        
        // Initialize on page load
        window.onload = function() {
            initApp();
            
            // Fix legend display - ensure only our custom legend is shown
            setTimeout(function() {
                document.querySelectorAll('.leaflet-control-attribution').forEach(function(el) {
                    el.style.display = 'none';
                });
            }, 100);
        };
        
        // Fix for ensuring coordinates are properly parsed
        function fixPropertyCoordinates(property) {
            // Ensure lat/lng are numeric values
            if (property.lat) property.lat = parseFloat(property.lat);
            if (property.lng) property.lng = parseFloat(property.lng);
            
            // Convert latitude/longitude to lat/lng if needed
            if (!property.lat && property.latitude) property.lat = parseFloat(property.latitude);
            if (!property.lng && property.longitude) property.lng = parseFloat(property.longitude);
            
            return property;
        }

        // Modify the property add function
        const originalAddPropertyToMap = addPropertyToMap;
        addPropertyToMap = function(property) {
            console.log("Adding property with coords:", property.lat, property.lng);
            return originalAddPropertyToMap(fixPropertyCoordinates(property));
        };

        // Also fix properties on load
        const originalLoadProperties = loadProperties;
        loadProperties = function() {
            console.log("Loading properties with coordinate fixing");
            return originalLoadProperties().then(function(result) {
                // Fix coordinates in all loaded properties
                propertiesData.forEach(fixPropertyCoordinates);
                return result;
            });
        };
    </script>

</body>
</html>
